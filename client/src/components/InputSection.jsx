// src/components/InputSection.jsx
import React, { useState, useRef, useEffect } from 'react';
import { getAuth } from 'firebase/auth';
import { db } from '../firebase';
import { collection, addDoc, serverTimestamp } from 'firebase/firestore';
import { getGeminiReply } from '../services/geminiApi';
import { franc } from 'franc';

function InputSection({ onReply }) {
  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const [input, setInput]           = useState('');
  const [isListening, setIsListening] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [inputMethod, setInputMethod] = useState(null);
  const [availableVoices, setAvailableVoices] = useState([]);
  const [voicesLoaded, setVoicesLoaded] = useState(false);

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ refs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const silenceTimerRef   = useRef(null);
  const recognitionRef    = useRef(null);
  const speechSynthesisRef = useRef(null);

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ user / lang ‚îÄ‚îÄ‚îÄ */
  const user     = getAuth().currentUser;
  const userLang = localStorage.getItem('lang') || 'en-IN';

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Enhanced voice setup with better loading ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    speechSynthesisRef.current = window.speechSynthesis;
    
    const loadVoices = () => {
      return new Promise((resolve) => {
        let voices = speechSynthesisRef.current?.getVoices() || [];
        
        if (voices.length > 0) {
          resolve(voices);
        } else {
          // Wait for voices to load
          const handleVoicesChanged = () => {
            voices = speechSynthesisRef.current?.getVoices() || [];
            if (voices.length > 0) {
              speechSynthesisRef.current.removeEventListener('voiceschanged', handleVoicesChanged);
              resolve(voices);
            }
          };
          
          speechSynthesisRef.current.addEventListener('voiceschanged', handleVoicesChanged);
          
          // Fallback timeout
          setTimeout(() => {
            speechSynthesisRef.current.removeEventListener('voiceschanged', handleVoicesChanged);
            resolve(speechSynthesisRef.current?.getVoices() || []);
          }, 3000);
        }
      });
    };
    
    const initializeVoices = async () => {
      try {
        const voices = await loadVoices();
        setAvailableVoices(voices);
        setVoicesLoaded(true);
        console.log('üé§ Loaded voices:', voices.map(v => `${v.name} (${v.lang}) - ${v.localService ? 'Local' : 'Remote'}`));
      } catch (error) {
        console.error('‚ùå Failed to load voices:', error);
        setVoicesLoaded(true); // Set to true anyway to prevent infinite loading
      }
    };
    
    initializeVoices();
    
    return () => {
      speechSynthesisRef.current?.cancel();
    };
  }, []);

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Enhanced voice selection with better native accent detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const selectBestVoice = (targetLang) => {
    if (!availableVoices.length) {
      console.warn('‚ö†Ô∏è No voices available');
      return null;
    }

    console.log(`üîç Searching for native voice for language: ${targetLang}`);
    
    // Enhanced voice patterns with native accent preferences
    const nativeVoicePatterns = {
      'hi-IN': {
        priority: [
          // Prefer local/native voices first
          { patterns: [/Google.*‡§π‡§ø‡§®‡•ç‡§¶‡•Ä/i, /Microsoft.*Kalpana/i, /Shreya/i], native: true },
          { patterns: [/hindi/i, /‡§π‡§ø‡§®‡•ç‡§¶‡•Ä/i], native: true },
          { patterns: [/Hemant/i, /Lekha/i], native: true }
        ],
        fallback: ['hi-IN', 'hi']
      },
      'te-IN': {
        priority: [
          { patterns: [/Google.*‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å/i, /Microsoft.*Heera/i, /Chitra/i], native: true },
          { patterns: [/telugu/i, /‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å/i], native: true }
        ],
        fallback: ['te-IN', 'te']
      },
      'ta-IN': {
        priority: [
          { patterns: [/Google.*‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç/i, /Microsoft.*Valluvar/i, /Karthik/i], native: true },
          { patterns: [/tamil/i, /‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç/i], native: true }
        ],
        fallback: ['ta-IN', 'ta', 'ta-LK']
      },
      'kn-IN': {
        priority: [
          { patterns: [/Google.*‡≤ï‡≤®‡≥ç‡≤®‡≤°/i, /Microsoft.*Suma/i], native: true },
          { patterns: [/kannada/i, /‡≤ï‡≤®‡≥ç‡≤®‡≤°/i], native: true }
        ],
        fallback: ['kn-IN', 'kn']
      },
      'mr-IN': {
        priority: [
          { patterns: [/Google.*‡§Æ‡§∞‡§æ‡§†‡•Ä/i, /Microsoft.*Omkar/i], native: true },
          { patterns: [/marathi/i, /‡§Æ‡§∞‡§æ‡§†‡•Ä/i], native: true }
        ],
        fallback: ['mr-IN', 'mr']
      },
      'bn-IN': {
        priority: [
          { patterns: [/Google.*‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ/i, /Microsoft.*Sushmita/i, /Bashkar/i], native: true },
          { patterns: [/bengali/i, /‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ/i], native: true }
        ],
        fallback: ['bn-IN', 'bn', 'bn-BD']
      },
      'gu-IN': {
        priority: [
          { patterns: [/Google.*‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä/i, /Microsoft.*Gujarati/i], native: true },
          { patterns: [/gujarati/i, /‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä/i], native: true }
        ],
        fallback: ['gu-IN', 'gu']
      },
      'ml-IN': {
        priority: [
          { patterns: [/Google.*‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç/i, /Microsoft.*Malayalam/i], native: true },
          { patterns: [/malayalam/i, /‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç/i], native: true }
        ],
        fallback: ['ml-IN', 'ml']
      },
      'pa-IN': {
        priority: [
          { patterns: [/Google.*‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä/i, /Microsoft.*Punjabi/i], native: true },
          { patterns: [/punjabi/i, /‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä/i], native: true }
        ],
        fallback: ['pa-IN', 'pa', 'pa-PK']
      },
      'ur-IN': {
        priority: [
          { patterns: [/Google.*ÿßÿ±ÿØŸà/i, /Microsoft.*Urdu/i], native: true },
          { patterns: [/urdu/i, /ÿßÿ±ÿØŸà/i], native: true }
        ],
        fallback: ['ur-IN', 'ur', 'ur-PK']
      },
      'en-IN': {
        priority: [
          { patterns: [/Google.*English.*India/i, /Microsoft.*Nandini/i, /Ravi/i], native: true },
          { patterns: [/english.*india/i, /indian/i], native: true }
        ],
        fallback: ['en-IN', 'en-US', 'en-GB']
      }
    };

    const config = nativeVoicePatterns[targetLang];
    if (!config) {
      console.warn(`‚ö†Ô∏è No voice configuration for ${targetLang}`);
      return availableVoices.find(v => v.lang === targetLang) || availableVoices[0];
    }

    // Step 1: Try priority patterns (native voices first)
    for (const priorityGroup of config.priority) {
      for (const pattern of priorityGroup.patterns) {
        const voice = availableVoices.find(v => {
          const match = pattern.test ? pattern.test(v.name) : v.name.toLowerCase().includes(pattern.toLowerCase());
          return match;
        });
        
        if (voice) {
          // Prefer local/native voices
          if (voice.localService || priorityGroup.native) {
            console.log(`‚úÖ Selected native voice: ${voice.name} (${voice.lang}) - Local: ${voice.localService}`);
            return voice;
          }
          console.log(`üîç Found voice but checking for better native option: ${voice.name}`);
        }
      }
    }

    // Step 2: Try exact language matches from fallback list
    for (const fallbackLang of config.fallback) {
      const voice = availableVoices.find(v => v.lang === fallbackLang);
      if (voice) {
        console.log(`‚úÖ Selected fallback voice: ${voice.name} (${voice.lang})`);
        return voice;
      }
    }

    // Step 3: Try any voice that starts with the base language
    const baseLang = targetLang.split('-')[0];
    const baseVoice = availableVoices.find(v => v.lang.startsWith(baseLang));
    if (baseVoice) {
      console.log(`‚úÖ Selected base language voice: ${baseVoice.name} (${baseVoice.lang})`);
      return baseVoice;
    }

    // Step 4: Ultimate fallback to English (India) or any English
    const englishIndia = availableVoices.find(v => v.lang === 'en-IN');
    if (englishIndia) {
      console.log(`‚ö†Ô∏è Fallback to English (India): ${englishIndia.name}`);
      return englishIndia;
    }

    const anyEnglish = availableVoices.find(v => v.lang.startsWith('en'));
    if (anyEnglish) {
      console.log(`‚ö†Ô∏è Fallback to English: ${anyEnglish.name}`);
      return anyEnglish;
    }

    console.log(`‚ö†Ô∏è Last resort: ${availableVoices[0]?.name}`);
    return availableVoices[0] || null;
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Enhanced TTS with better reliability and multiple attempts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const speak = async (text, lang) => {
    if (!voicesLoaded) {
      console.warn('‚ö†Ô∏è Voices not loaded yet, waiting...');
      setTimeout(() => speak(text, lang), 500);
      return;
    }

    const synth = speechSynthesisRef.current;
    if (!synth || !text.trim()) {
      console.warn('‚ö†Ô∏è Speech synthesis not available or empty text');
      return;
    }
    
    // Cancel any ongoing speech
    synth.cancel();
    
    // Wait for cancel to complete
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const attemptSpeech = (attempt = 1, maxAttempts = 3) => {
      return new Promise((resolve, reject) => {
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Configure speech parameters for better quality
        utterance.lang = lang;
        utterance.rate = lang.startsWith('hi') || lang.startsWith('te') || lang.startsWith('ta') ? 0.8 : 0.85;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        // Select the best voice
        const selectedVoice = selectBestVoice(lang);
        if (selectedVoice) {
          utterance.voice = selectedVoice;
          console.log(`üé§ Attempt ${attempt}: Speaking with voice: ${selectedVoice.name} (${selectedVoice.lang})`);
        } else {
          console.warn(`‚ö†Ô∏è Attempt ${attempt}: No suitable voice found, using system default`);
        }
        
        let speechStarted = false;
        let speechEnded = false;
        
        utterance.onstart = () => {
          speechStarted = true;
          console.log(`üéµ Speech started successfully on attempt ${attempt}`);
        };
        
        utterance.onend = () => {
          speechEnded = true;
          console.log(`üéµ Speech ended successfully on attempt ${attempt}`);
          resolve();
        };
        
        utterance.onerror = (e) => {
          console.error(`üö´ Speech error on attempt ${attempt}:`, e);
          if (attempt < maxAttempts) {
            console.log(`üîÑ Retrying speech attempt ${attempt + 1}...`);
            setTimeout(() => {
              attemptSpeech(attempt + 1, maxAttempts)
                .then(resolve)
                .catch(reject);
            }, 300);
          } else {
            reject(e);
          }
        };
        
        try {
          synth.speak(utterance);
          
          // Check if speech started within reasonable time
          setTimeout(() => {
            if (!speechStarted && !speechEnded) {
              console.warn(`‚ö†Ô∏è Speech didn't start within timeout on attempt ${attempt}`);
              if (attempt < maxAttempts) {
                synth.cancel();
                setTimeout(() => {
                  attemptSpeech(attempt + 1, maxAttempts)
                    .then(resolve)
                    .catch(reject);
                }, 300);
              } else {
                reject(new Error('Speech failed to start'));
              }
            }
          }, 1000);
          
        } catch (error) {
          console.error(`‚ùå Speech synthesis error on attempt ${attempt}:`, error);
          if (attempt < maxAttempts) {
            setTimeout(() => {
              attemptSpeech(attempt + 1, maxAttempts)
                .then(resolve)
                .catch(reject);
            }, 300);
          } else {
            reject(error);
          }
        }
      });
    };
    
    try {
      await attemptSpeech();
    } catch (error) {
      console.error('‚ùå All speech attempts failed:', error);
      
      // Try English fallback if original language failed
      if (lang !== 'en-IN' && lang !== 'en-US') {
        console.log('üîÑ Trying English fallback...');
        try {
          await attemptSpeech(1, 2); // Fewer attempts for fallback
        } catch (fallbackError) {
          console.error('‚ùå English fallback also failed:', fallbackError);
        }
      }
    }
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  useEffect(() => {
    return () => {
      clearTimeout(silenceTimerRef.current);
      recognitionRef.current?.stop();
      speechSynthesisRef.current?.cancel();
    };
  }, []);

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ language detect ‚îÄ‚îÄ‚îÄ */
  const detectLanguage = (text) => {
    if (text.length < 3) return userLang;
    const map = {
      hin: 'hi-IN', tel: 'te-IN', tam: 'ta-IN', kan: 'kn-IN',
      eng: 'en-IN', mar: 'mr-IN', ben: 'bn-IN', guj: 'gu-IN',
      mal: 'ml-IN', pan: 'pa-IN', urd: 'ur-IN'
    };
    const code = franc(text, { minLength: 3, only: Object.keys(map) });
    return map[code] || userLang;
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ start / stop SR ‚îÄ‚îÄ‚îÄ */
  const stopListening = () => {
    clearTimeout(silenceTimerRef.current);
    recognitionRef.current?.stop();
    setIsListening(false);
  };

  const startListening = () => {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return alert('Speech Recognition not supported in this browser');
    
    recognitionRef.current = new SR();
    recognitionRef.current.lang = userLang;
    recognitionRef.current.interimResults = true;
    recognitionRef.current.continuous = true;
    recognitionRef.current.maxAlternatives = 1;

    const resetSilence = () => {
      clearTimeout(silenceTimerRef.current);
      silenceTimerRef.current = setTimeout(stopListening, 3000);
    };

    recognitionRef.current.onresult = (e) => {
      resetSilence();
      const transcript = Array.from(e.results).map(r => r[0].transcript).join('');
      if (e.results[e.results.length - 1].isFinal) {
        setInputMethod('speech');
        handleSubmit(transcript, detectLanguage(transcript));
      }
    };
    
    recognitionRef.current.onerror = (err) => { 
      console.error('Speech recognition error:', err); 
      stopListening(); 
    };
    
    recognitionRef.current.onend = () => { 
      setIsListening(false); 
      setIsProcessing(false); 
    };

    setIsListening(true);
    recognitionRef.current.start();
    resetSilence();
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ handle submit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const handleSubmit = async (textVal, forcedLang) => {
    const finalInput = textVal || input.trim();
    if (!finalInput) return;

    setIsProcessing(true);
    try {
      const responseLang = forcedLang || detectLanguage(finalInput);
      const langCode = responseLang.slice(0, 2);

      /* ---------- EMOTIONAL PROMPT ---------- */
      const prompt = `
You are a wise, emotionally strong Indian woman (like an elder sister or trusted midwife).
Give a short, warm, and deeply empathetic reply in ${langCode}.
if user mentions any symptoms related to health, give suggestions accordingly. keep in mind that the user is either in pregnancy or prepreganncy or post pregnancy.
‚Ä¢ 2‚Äë3 concise lines
‚Ä¢ Gentle reassurance, emotional support
‚Ä¢ A dash of motivation or cultural wisdom if fitting
User said:
"${finalInput}"`;

      const reply = await getGeminiReply(prompt, langCode);

      /* update UI */
      onReply(reply, responseLang, inputMethod || 'text');
      
      /* speak with enhanced voice selection - ALWAYS speak the response */
      console.log(`üé§ Speaking response in ${responseLang}: "${reply.substring(0, 50)}..."`);
      await speak(reply, responseLang);
      
      setInput('');
      setInputMethod(null);

      /* store entry */
      if (user) {
        console.log('üì¶ Saving entry for UID:', user.uid);
        await addDoc(collection(db, 'users', user.uid, 'entries'), {
          input: finalInput,
          response: reply,
          lang: responseLang,
          inputMethod: inputMethod || 'text',
          createdAt: serverTimestamp()
        });
      } else {
        console.warn('‚ö†Ô∏è No authenticated user, skipping Firestore write');
      }
    } catch (err) {
      console.error('Gemini error', err);
      const fallback = userLang.startsWith('hi')
        ? '‡§ï‡•ç‡§∑‡§Æ‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§Ö‡§≠‡•Ä ‡§â‡§§‡•ç‡§§‡§∞ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§'
        : 'Sorry, Im unable to respond right now. Please try again.';
      onReply(fallback, userLang, inputMethod || 'text');
      await speak(fallback, userLang);
    } finally {
      setIsProcessing(false);
    }
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ text submit click ‚îÄ */
  const handleTextSubmit = () => { 
    setInputMethod('text'); 
    handleSubmit(); 
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ translations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const translations = {
    'hi-IN': { ph:'‡§ú‡§®‡§®‡•Ä ‡§∏‡•á ‡§¨‡§æ‡§§ ‡§ï‡§∞‡•á‡§Ç...', send:'‡§≠‡•á‡§ú‡•á‡§Ç', mic:'‡§¨‡•ã‡§≤‡•á‡§Ç', test:'‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ü‡•á‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç' },
    'te-IN': { ph:"‡∞ú‡∞®‡∞®‡∞ø‡∞§‡±ã ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø...", send:'‡∞™‡∞Ç‡∞™‡±Å', mic:'‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡±Å', test:'‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞ü‡±Ü‡∞∏‡±ç‡∞ü‡±ç' },
    'ta-IN': { ph:"‡Æú‡Æ©‡Æ©‡Æø‡ÆØ‡ØÅ‡Æü‡Æ©‡Øç ‡Æ™‡Øá‡Æö‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç...", send:'‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ', mic:'‡Æ™‡Øá‡Æö', test:'‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øç ‡Æö‡Øã‡Æ§‡Æ©‡Øà' },
    'kn-IN': { ph:"‡≤ú‡≤®‡≤®‡≤ø‡≤Ø‡≥ä‡≤Ç‡≤¶‡≤ø‡≤ó‡≥Ü ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø...", send:'‡≤ï‡≤≥‡≥Å‡≤π‡≥Ü', mic:'‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø', test:'‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤™‡≤∞‡≥Ä‡≤ï‡≥ç‡≤∑‡≥Ü' },
    'mr-IN': { ph:"‡§ú‡§®‡§®‡•Ä‡§∏‡•ã‡§¨‡§§ ‡§¨‡•ã‡§≤‡§æ...", send:'‡§™‡§æ‡§†‡§µ‡§æ', mic:'‡§¨‡•ã‡§≤‡§æ', test:'‡§Ü‡§µ‡§æ‡§ú ‡§ö‡§æ‡§ö‡§£‡•Ä' },
    'bn-IN': { ph:"‡¶ú‡¶®‡¶®‡¶ø‡¶∞ ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßÅ‡¶®...", send:'‡¶™‡¶æ‡¶†‡¶æ‡¶®', mic:'‡¶¨‡¶≤‡ßÅ‡¶®', test:'‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶ü‡ßá‡¶∏‡ßç‡¶ü' },
    'gu-IN': { ph:"‡™ú‡™®‡™®‡´Ä ‡™∏‡™æ‡™•‡´á ‡™µ‡™æ‡™§ ‡™ï‡™∞‡´ã...", send:'‡™Æ‡´ã‡™ï‡™≤‡´ã', mic:'‡™¨‡´ã‡™≤‡´ã', test:'‡™Ö‡™µ‡™æ‡™ú ‡™ü‡´á‡™∏‡´ç‡™ü' },
    'ml-IN': { ph:"‡¥ú‡¥®‡¥®‡¥ø‡¥Ø‡µÅ‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï...", send:'‡¥Ö‡¥Ø‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï', mic:'‡¥∏‡¥Ç‡¥∏‡¥æ‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï', test:'‡¥∂‡¥¨‡µç‡¥¶ ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥®' },
    'pa-IN': { ph:"‡®ú‡®®‡®®‡©Ä ‡®®‡®æ‡®≤ ‡®ó‡©±‡®≤ ‡®ï‡®∞‡©ã...", send:'‡®≠‡©á‡®ú‡©ã', mic:'‡®¨‡©ã‡®≤‡©ã', test:'‡®Ü‡®µ‡®æ‡®ú‡®º ‡®ü‡©à‡®∏‡®ü' },
    'ur-IN': { ph:'ÿßŸæŸÜÿß ÿ≥ŸàÿßŸÑ ŸÑ⁄©⁄æ€å⁄∫...', send:'ÿ®⁄æ€åÿ¨€å⁄∫', mic:'ÿ®ŸàŸÑ€å⁄∫', test:'ÿ¢Ÿàÿßÿ≤ Ÿπ€åÿ≥Ÿπ' },
    default: { ph:'Talk to Janani...', send:'Send', mic:'Speak', test:'Test Voice' }
  };
  
  const t = translations[userLang] || translations.default;
  const { ph: placeholder, send, mic: speakLabel, test: testLabel } = t;

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Test voice function ‚îÄ‚îÄ‚îÄ */
  const testVoice = () => {
    const testMessages = {
      'hi-IN': '‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•à‡§Ç ‡§ú‡§®‡§®‡•Ä ‡§π‡•Ç‡§Ç‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Ç ‡§π‡•Ç‡§Ç‡•§',
      'te-IN': '‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç, ‡∞®‡±á‡∞®‡±Å ‡∞ú‡∞®‡∞®‡∞ø. ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç ‡∞ö‡±á‡∞Ø‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞®‡±á‡∞®‡±Å ‡∞á‡∞ï‡±ç‡∞ï‡∞° ‡∞â‡∞®‡±ç‡∞®‡∞æ‡∞®‡±Å.',
      'ta-IN': '‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç, ‡Æ®‡Ææ‡Æ©‡Øç ‡Æú‡Æ©‡Æ©‡Æø. ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æ§‡Æµ ‡Æ®‡Ææ‡Æ©‡Øç ‡Æá‡Æô‡Øç‡Æï‡Øá ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç.',
      'kn-IN': '‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞, ‡≤®‡≤æ‡≤®‡≥Å ‡≤ú‡≤®‡≤®‡≤ø. ‡≤®‡≤ø‡≤Æ‡≤ó‡≥Ü ‡≤∏‡≤π‡≤æ‡≤Ø ‡≤Æ‡≤æ‡≤°‡≤≤‡≥Å ‡≤®‡≤æ‡≤®‡≥Å ‡≤á‡≤≤‡≥ç‡≤≤‡≤ø‡≤¶‡≥ç‡≤¶‡≥á‡≤®‡≥Ü.',
      'mr-IN': '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞, ‡§Æ‡•Ä ‡§ú‡§®‡§æ‡§®‡•Ä. ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§Ø‡•á‡§•‡•á ‡§Ü‡§π‡•á.',
      'bn-IN': '‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞, ‡¶Ü‡¶Æ‡¶ø ‡¶ú‡¶®‡¶®‡¶ø‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶õ‡¶ø‡•§',
      'gu-IN': '‡™®‡™Æ‡™∏‡´ç‡™§‡´á, ‡™π‡´Å‡™Ç ‡™ú‡™®‡™®‡´Ä. ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™æ‡™∞‡´Ä ‡™Æ‡™¶‡™¶ ‡™Æ‡™æ‡™ü‡´á ‡™Ö‡™π‡´Ä‡™Ç ‡™õ‡´Å‡™Ç.',
      'ml-IN': '‡¥®‡¥Æ‡¥∏‡µç‡¥ï‡¥æ‡¥∞‡¥Ç, ‡¥û‡¥æ‡µª ‡¥ú‡¥®‡¥®‡¥ø. ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÜ ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥û‡¥æ‡µª ‡¥á‡¥µ‡¥ø‡¥ü‡µÜ‡¥Ø‡µÅ‡¥£‡µç‡¥ü‡µç.',
      'pa-IN': '‡®∏‡®§ ‡®∏‡©ç‡®∞‡©Ä ‡®Ö‡®ï‡®æ‡®≤, ‡®Æ‡©à‡®Ç ‡®ú‡®®‡®®‡©Ä ‡®π‡®æ‡®Ç‡•§ ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®°‡©Ä ‡®Æ‡®¶‡®¶ ‡®≤‡®à ‡®á‡©±‡®•‡©á ‡®π‡®æ‡®Ç‡•§',
      'ur-IN': 'ÿ≥ŸÑÿßŸÖÿå ŸÖ€å⁄∫ ÿ¨ŸÜŸÜ€å €ÅŸà⁄∫€î ŸÖ€å⁄∫ ÿ¢Ÿæ ⁄©€å ŸÖÿØÿØ ⁄©€í ŸÑ€å€í €å€Åÿß⁄∫ €ÅŸà⁄∫€î',
      'en-IN': 'Hello, I am Janani. I am here to help you.'
    };
    
    const testMessage = testMessages[userLang] || testMessages['en-IN'];
    speak(testMessage, userLang);
  };

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  return (
    <div className="p-4 bg-white shadow rounded-xl w-full max-w-2xl">
      <div className="flex items-center gap-2">
        <input
          type="text"
          placeholder={placeholder}
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyDown={e => e.key === 'Enter' && handleTextSubmit()}
          className="flex-1 border p-2 rounded-lg"
          disabled={isProcessing}
        />
        <button
          onClick={handleTextSubmit}
          disabled={isProcessing}
          className="px-4 py-2 rounded-lg bg-pink-500 text-white hover:bg-pink-600 disabled:opacity-50"
        >
          {isProcessing ? '...' : send}
        </button>
        <button
          onClick={isListening ? stopListening : startListening}
          disabled={isProcessing}
          className={`px-4 py-2 rounded-lg text-white hover:bg-pink-600 disabled:opacity-50 ${
            isListening ? 'bg-red-500' : 'bg-pink-500'
          }`}
          title={speakLabel}
        >
          {isProcessing ? '...' : 'üéôÔ∏è'}
        </button>
      </div>
      
      {/* Enhanced debug info for development */}
      {process.env.NODE_ENV === 'development' && (
        <div className="mt-2 text-xs text-gray-500 space-y-1">
          <div>
            Available voices: {availableVoices.length} | User lang: {userLang} | Voices loaded: {voicesLoaded ? '‚úÖ' : '‚è≥'}
          </div>
          <div className="max-h-20 overflow-y-auto">
            <strong>Native voices:</strong> {availableVoices
              .filter(v => v.localService || v.lang.includes(userLang.split('-')[0]))
              .map(v => `${v.name} (${v.lang}) ${v.localService ? 'üìç' : '‚òÅÔ∏è'}`)
              .join(', ') || 'None found'}
          </div>
          <div className="flex gap-2">
            <button 
              onClick={testVoice}
              disabled={!voicesLoaded}
              className="px-2 py-1 bg-blue-500 text-white rounded text-xs disabled:opacity-50"
            >
              {testLabel}
            </button>
            <button 
              onClick={() => {
                console.log('üîç Available voices:', availableVoices);
                console.log('üéØ Selected voice for', userLang, ':', selectBestVoice(userLang));
              }}
              className="px-2 py-1 bg-green-500 text-white rounded text-xs"
            >
              Debug Voices
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

export default InputSection;